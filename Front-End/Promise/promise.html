

  <script src="./myPromise.js"></script>
  <!-- <script>
    console.log("------test start------")
    const p = new MyPromise((resolve,reject) => {
      // resolve('OK')
      // reject('err')
      // throw 'throw-error'
      setTimeout( () => {
        // *原Promise也是异步代码捕获不到错误的！
        // throw new Error('throw-new-Error')  
        // console.log(cc)
        reject('reject-ok')
        resolve('success-ok')
      },3000)

    })

    // new Promise中有异步代码时
    //    return undefined使得then方法返回的是pending状态的promise，当修改状态后，才变为了成功的promise
    const p1 = p.then(value => {
      console.log("p1-",value)
      throw 'throw-error'
      // return "normal return"
    },reason => {
      console.log(reason)
      // console.log(cc)
      throw 'throw-error'
      // return "reject return"
    }).catch(reason => {
      console.log(reason)
    })

    const p2 = p.then(value => {
      console.log("p2-",value)
      return new MyPromise((res,rej) => {
        res('return-success-promise')
      })
    },reason => {
      console.warn(reason)
      return new MyPromise((res,rej) => {
        rej('return-rejected-promise')
        // throw 'return-throw-promise'
        // res('success')
      })
    }).catch(reason => {
      console.log(reason)
    })


    // 异常穿透，值传递
    const h = new MyPromise((resolve,reject) => {
      // setTimeout(() => {
        reject('异常穿透')
      // },3000)
    })

    h.then(val => {
      console.log(val)
    }).then(val => {
      console.log(val)
    }).then(val => {
      console.log(val)
    }).catch(reason => {
      console.log(reason)
    })

    h.then().then().catch(reason => {
      console.log(reason)
      return '值传递'
    }).catch(reason => {
      console.log(reason)
    }).then(val => {
      console.log(val)
    })


    // 返回错误的promise不捕获的话，会有红色错误抛出
    //    new了三个Promise，then，resolve，new
    const t = MyPromise.resolve(new MyPromise((res,rej) => {
      // rej('df')
      // res('df')
      throw 'dfa'
      // console.log(hh)
    }))

    // t.then(undefined,() => {})
    t.catch(reason => {
      console.log(reason)
    })

    const t1 = MyPromise.reject(new MyPromise((res,rej) => {
      res('ok')
    }))
    
    t1.catch(reason => {
      console.log(t1,reason)
    })
    


    const r1 = new MyPromise((res,rej) => {
      setTimeout(() => {
        res('r1')
      },4000)
    })
    const r2 = new MyPromise((res,rej) => {
      setTimeout(() => {
        rej('r2')
      },1000)
    })

    const r3 = new MyPromise((res,rej) => {
      setTimeout(() => {
        res('r3')
      })
    })

    const r = MyPromise.all([r2,r1,r3])
    const L = MyPromise.race([r3,r1,r2])// 最先settled！
    console.log(r)
    console.log(L)



    const m = new MyPromise((res,rej) => {
      console.log('111')
      res()
    })
  
    m.then(val => {
      console.log('222')
    })

    console.log('333')

  </script>    -->

  <!-- <script>
    console.log("------test start------")
    const p = new Promise((resolve,reject) => {
      // resolve('OK')
      // reject('err')
      // throw 'throw-error'
      setTimeout( () => {
        // *原Promise也是异步代码捕获不到错误的！
        // throw new Error('throw-new-Error')  
        // console.log(cc)
        reject('reject-ok')
        resolve('success-ok')
      },3000)

    })

    // new Promise中有异步代码时
    //    return undefined使得then方法返回的是pending状态的promise，当修改状态后，才变为了成功的promise
    const p1 = p.then(value => {
      console.log("p1-",value)
      throw 'throw-error'
      // return "normal return"
    },reason => {
      console.log(reason)
      // console.log(cc)
      throw 'throw-error'
      // return "reject return"
    }).catch(reason => {
      console.log(reason)
    })

    const p2 = p.then(value => {
      console.log("p2-",value)
      return new Promise((res,rej) => {
        res('return-success-promise')
      })
    },reason => {
      console.warn(reason)
      return new Promise((res,rej) => {
        rej('return-rejected-promise')
        // throw 'return-throw-promise'
        // res('success')
      })
    }).catch(reason => {
      console.log(reason)
    })


    // 异常穿透，值传递
    const h = new Promise((resolve,reject) => {
      // setTimeout(() => {
        reject('异常穿透')
      // },3000)
    })

    h.then(val => {
      console.log(val)
    }).then(val => {
      console.log(val)
    }).then(val => {
      console.log(val)
    }).catch(reason => {
      console.log(reason)
    })

    h.then().then().catch(reason => {
      console.log(reason)
      return '值传递'
    }).catch(reason => {
      console.log(reason)
    }).then(val => {
      console.log(val)
    })


    // 返回错误的promise不捕获的话，会有红色错误抛出
    //    new了三个Promise，then，resolve，new
    const t = Promise.resolve(new Promise((res,rej) => {
      // rej('df')
      // res('df')
      throw 'dfa'
      // console.log(hh)
    }))

    // t.then(undefined,() => {})
    t.catch(reason => {
      console.log(reason)
    })

    const t1 = Promise.reject(new Promise((res,rej) => {
      res('ok')
    }))
    
    t1.catch(reason => {
      console.log(t1,reason)
    })
    


    const r1 = new Promise((res,rej) => {
      setTimeout(() => {
        res('r1')
      },4000)
    })
    const r2 = new Promise((res,rej) => {
      setTimeout(() => {
        rej('r2')
      },1000)
    })

    const r3 = new Promise((res,rej) => {
      setTimeout(() => {
        res('r3')
      })
    })

    const r = Promise.all([r2,r1,r3])
    const L = Promise.race([r3,r1,r2])// 最先settled！
    console.log(r)
    console.log(L)



    const m = new Promise((res,rej) => {
      console.log('111')
      res()
    })

    m.then(val => {
      console.log('222')
    })

    console.log('333')

  </script>  
   -->

<!--   
  <script>

    const p = new MyPromise((resolve,reject) => {
    // 1、内部同步代码执行测试
      // resolve('resolve')
      // reject('reject')
      // throw 'throw-error'
      // console.log(cc)

    // 2、内部异步代码执行配合then
      setTimeout(() => {
        resolve('resolve')
        // reject('reject')
      
      // 异步代码执行try catch无法捕获异常！
        // throw 'throw-error'
        // console.log(cc)

      })
    })

    console.log(p)

    const p1 = p.then(value => {
      console.log(value)
      // return 'return-value is not Promsie'
      return new MyPromise((resolve,reject) => {
        // resolve('return_value is Promise，resolve')
        // reject('return_value is Promise，reject')
        throw 'return_value is Promise，throw'
      })
    },reason => {
      console.log(reason)
      // return 'return-value is not Promsie'
      return new MyPromise((resolve,reject) => {
        resolve('return_value is Promise，resolve')
        // reject('return_value is Promise，reject')
        // throw 'return_value is Promise，throw'
      })
    })
    console.log(p1)

  </script> -->
<!-- 
  <script>

    const c = 123
    const t = new Promise((resolve,reject) => {
      reject('异常穿透')
    })
    t.then(val => {
      console.log(val)
    }).then(val => {
      console.log(val)
    },c).catch(reason => {
      console.log('catch：',reason)
    })

    const m = new Promise((resolve,reject) => {
      resolve('值传递')
    })
    m.then().then().then(val => {
      console.log('1-then',val)
    })
    const a = 1
    const b = 'hh'
    m.then(a).then(b).then(val => {
      console.log('2-then',val)
    })

  </script> -->
<!-- 
  <script>

    const k = new MyPromise((resolve,reject) => {
      resolve('resolve')
      reject('reject')
    })
    const k1 = k.then().then(val => {
      throw 'throw-resolve'
    }).catch(reason => {
      return new MyPromise((resolve,reject) => {
        reject('finally-rejected')
        // resolve('finally-fullfilled')
      })
    }).finally((data) => {
      console.log(data,'onFinally')
      // throw 'new-throw'
    })
    console.log(k1)

  </script> -->
<!-- 
  <script>
    const p = new Promise((resolve,reject) => {
      reject('hello')
    }).then(v => {
      console.log(v)
    })
  </script> -->

  <script>

    // var p1 = new Promise(function(resolve, reject) {
    //   resolve('Success');
    // });

    // p1.then(function(value) {
    //   console.log('A1-',value); // "Success!"
    //   throw 'oh, no!';
    // }).catch(function(e) {
    //   console.log('A2-',e); // "oh, no!"
    // }).then(function(){
    //   console.log('A3-after a catch the chain is restored');
    // }, function () {
    //   console.log('Not fired due to the catch');
    // });

    // // 以下行为与上述相同
    // p1.then(function(value) {
    //   console.log('B1-',value); // "Success!"
    //   return Promise.reject('oh, no!');
    // }).catch(function(e) {
    //   console.log('B2-',e); // "oh, no!"
    // }).then(function(){
    //   console.log('B3-after a catch the chain is restored');
    // }, function () {
    //   console.log('Not fired due to the catch');
    // });

    const p = MyPromise.resolve("foo")
    // 1. 接收 "foo" 并与 "bar" 拼接，并将其结果做为下一个 resolve 返回。
    .then(function(string) {
      console.log('then-1')
      return new MyPromise(function(resolve, reject) {
        setTimeout(function() {
          console.log('setTimeout-1')
          string += 'bar';
          resolve(string);
        }, 1);
      });
    })
    // // 2. 接收 "foobar", 放入一个异步函数中处理该字符串
    // // 并将其打印到控制台中, 但是不将处理后的字符串返回到下一个。
    .then(function(string) {
      console.log('then-2')
      setTimeout(function() {
        console.log('setTimeout-2')
        string += 'baz';
        console.log(string);
      }, 1)
      return string;
    })
    // 3. 打印本节中代码将如何运行的帮助消息，
    // 字符串实际上是由上一个回调函数之前的那块异步代码处理的。
    .then(function(string) {
      console.log('then-3')
      console.log('setTimeout-3')
      console.log("Last Then:  oops... didn't bother to instantiate and return " +
                  "a promise in the prior then so the sequence may be a bit " +
                  "surprising");

      // 注意 `string` 这时不会存在 'baz'。
      // 因为这是发生在我们通过setTimeout模拟的异步函数中。
      console.log(string);
    });

  // logs, in order:
  // Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising
  // foobar
  // foobarbaz

  </script> 